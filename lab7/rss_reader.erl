-module(rss_reader).
-include("logging.hrl").
-compile(export_all).
-define(RETRIEVE_INTERVAL,10000).

%% @doc start(Url, QPid)
%% Запуск сервера
start(Url,QPid)->
	inets:start(),
	spawn(?MODULE,server,[Url,QPid]).

%% @doc реализация чтения
%% Загружаем ленту с указанного URL, с помощью функции httpc:request/1.
%% Если код ответа равен 200, извлекаем тело ответа и разбирает его XML содержимое с помощью функции xmerl_scan:string/1.
%% Когда информация извлечена из тела запроса, проверяем, что получена лента в формате RSS 2.0. Для этого есть написанная в задании 3 функция rss_parse:is_rss2_feed/1.
%% Если все вышеперечисленные шаги завершились без ошибок, с помощью написанной в прошлом задании вспомогательной функции rss_queue:add_feed/2 отправляем все элементы ленты в очередь, которая стоит в паре с этим процессом чтения.
%% Ждем заданное время, затем возвращаемся к началу и продолжаем все заново.

%% Обычно, процессы чтения RSS новостей обновляют свои ленты через большие интервалы времени, начиная с 15 минут до часа. Однако, так вам будет сложно тестировать свою программу, поэтому на время разработки этот интервал можно уменьшить до 60 секунд или около того. Объявите с помощью макроса константу, например, RETRIEVE_INTERVAL, с тем чтобы в последствии вы могли бы легко изменить значение таймаута не отыскивая место в коде, где он используется.

server(Url, QPid)->
	?INFO("URL ~s~n", [Url]),
	{ok,{{_,Code,_},_,Load}}=httpc:request(Url),
	case Code of 
		200 ->
			{RSS,_} = xmerl_scan:string(Load),
			case rss_parse:is_rss2_feed(RSS) of
				ok -> 
					rss_queue:add_feed(QPid,RSS),
					receive
					after ?RETRIEVE_INTERVAL -> 
						server(Url, QPid)
					end;
				_ ->
					erlang:exit(not_rss2_feed)
			end;
		_ -> erlang:exit(Code)
	end.